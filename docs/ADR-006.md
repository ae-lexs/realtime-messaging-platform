# ADR-006: REST API Contract

- **Status**: Accepted
- **Date**: 2026-01-31

---

## Context and Problem Statement

ADR-001 through ADR-005 established the foundational architecture for real-time messaging: per-chat ordering with server-assigned sequences, three-plane separation, DynamoDB as the source of truth, atomic counter-based sequence allocation, and a WebSocket protocol for real-time communication. ADR-001 explicitly stated:

> "**REST APIs** for chat management and message history. **WebSocket protocol** for real-time messaging, acknowledgments, and sync."

This separation is intentional: REST APIs handle operations that are naturally request-response (creating chats, managing members, fetching history), while WebSockets handle operations that benefit from persistent connections (real-time message delivery, typing indicators, presence).

However, the REST API contract remains unspecified. Without explicit definitions, implementations will diverge on:

- Resource naming conventions and URL structure
- Request/response schemas and field names
- Authentication and authorization patterns
- Error response formats and codes
- Pagination strategies for list endpoints
- Consistency guarantees for read operations

**Core Question:** What is the complete REST API specification that governs chat management, message history retrieval, and user operations in the messaging system?

> **Note**: This ADR focuses on **REST API contract, endpoints, and request/response schemas**. For the underlying data model, table schemas, and DynamoDB access patterns, see **[ADR-007: Data Model and Index Strategy](./ADR-007.md)**.

---

## Decision Drivers

1. **Consistency with WebSocket Protocol**: REST and WebSocket APIs must use consistent naming, schemas, and semantics. A `chat_id` in REST must match `chat_id` in WebSocket messages.

2. **RESTful Design**: Follow REST principles where they add value; pragmatically deviate where they don't (e.g., use POST for complex queries if needed).

3. **Security-First**: Every endpoint must have clear authentication and authorization requirements. No accidental exposure of data.

4. **Debuggability**: Consistent error formats, request IDs for tracing, and predictable behavior under failure conditions.

5. **Performance-Aware**: Pagination for all list endpoints. Efficient queries that align with DynamoDB access patterns (ADR-003).

6. **Mobile-Friendly**: Minimize round trips. Support partial updates. Consider bandwidth constraints.

7. **Evolvability**: Version the API. Design for backward-compatible evolution.

---

## Considered Options

### Option 1: Pure REST (Resource-Oriented)

Strict adherence to REST principles with resources, sub-resources, and standard HTTP verbs.

**Mechanism**: `/chats/{id}`, `/chats/{id}/messages`, `/chats/{id}/members`, etc.

### Option 2: GraphQL

Single endpoint with flexible queries and mutations.

**Mechanism**: `/graphql` endpoint with schema-defined operations.

### Option 3: RPC-Style (Action-Oriented)

Action-based endpoints that map to operations rather than resources.

**Mechanism**: `/api/createChat`, `/api/sendMessage`, `/api/addMember`, etc.

### Option 4: Hybrid REST with Pragmatic Deviations

Resource-oriented design with pragmatic deviations for complex operations.

**Mechanism**: REST for CRUD, custom endpoints for complex workflows.

---

## Decision Outcome

**Chosen Option: Option 4 — Hybrid REST with Pragmatic Deviations**

This approach provides the clarity and predictability of REST while allowing pragmatic deviations for operations that don't fit the CRUD model cleanly. The API is organized around resources (users, chats, messages) but includes action endpoints where they improve clarity (e.g., `/chats/{id}/leave` instead of `DELETE /chats/{id}/members/me`).

### API Overview

```mermaid
flowchart TB
    subgraph AUTH
        AUTH_TITLE["AUTHENTICATION DOMAIN<br/>POST /api/v1/auth/*"]
        AUTH1["/auth/request-otp"]
        AUTH2["/auth/verify-otp"]
        AUTH3["/auth/refresh"]
        AUTH4["/auth/logout"]
        AUTH_TITLE --> AUTH1
    end
    
    subgraph USERS
        USERS_TITLE["USER DOMAIN<br/>GET/PATCH /api/v1/users/*"]
        U1["GET /users/me"]
        U2["PATCH /users/me"]
        U3["GET /users/{id}"]
        USERS_TITLE --> U1
    end
    
    subgraph CHATS
        CHATS_TITLE["CHAT DOMAIN<br/>/api/v1/chats/*"]
        C1["POST /chats"]
        C2["GET /chats"]
        C3["GET /chats/{id}"]
        C4["PATCH /chats/{id}"]
        C5["POST /chats/{id}/members"]
        C6["DELETE /chats/{id}/members/{user_id}"]
        C7["POST /chats/{id}/leave"]
        CHATS_TITLE --> C1
    end
    
    subgraph MESSAGES
        MSG_TITLE["MESSAGE DOMAIN<br/>GET /api/v1/chats/{id}/messages"]
        M1["GET /chats/{id}/messages"]
        M2["GET /chats/{id}/messages/{message_id}"]
        MSG_TITLE --> M1
    end
    
    subgraph SESSIONS
        SESS_TITLE["SESSION DOMAIN<br/>/api/v1/sessions/*"]
        S1["GET /sessions"]
        S2["DELETE /sessions/{id}"]
        S3["DELETE /sessions"]
        SESS_TITLE --> S1
    end
    
    CLIENT((Client)) --> AUTH
    CLIENT --> USERS
    CLIENT --> CHATS
    CLIENT --> MESSAGES
    CLIENT --> SESSIONS
    
    style AUTH fill:#e3f2fd,stroke:#1565c0
    style AUTH_TITLE fill:#e3f2fd,stroke:#1565c0
    style USERS fill:#e8f5e9,stroke:#2e7d32
    style USERS_TITLE fill:#e8f5e9,stroke:#2e7d32
    style CHATS fill:#fff3e0,stroke:#e65100
    style CHATS_TITLE fill:#fff3e0,stroke:#e65100
    style MESSAGES fill:#fce4ec,stroke:#c2185b
    style MSG_TITLE fill:#fce4ec,stroke:#c2185b
    style SESSIONS fill:#f3e5f5,stroke:#7b1fa2
    style SESS_TITLE fill:#f3e5f5,stroke:#7b1fa2
```

### Foundational Principles

| Principle | Description |
|-----------|-------------|
| **Resource-Oriented** | URLs identify resources; HTTP verbs indicate actions |
| **Consistent Naming** | snake_case for JSON fields, matching WebSocket protocol (ADR-005) |
| **Explicit Versioning** | API version in URL path (`/api/v1/...`) |
| **Authentication Required** | All endpoints except auth require valid JWT |
| **Authorization Enforced** | Resource access validated against membership/ownership |
| **Idempotency Support** | POST/PATCH operations support `Idempotency-Key` header |
| **Request Tracing** | All requests accept `X-Request-ID` header; responses echo it |

---

## Detailed Design

### 1. Common Conventions

#### 1.1 Base URL

```
Production:  https://api.example.com/api/v1
Staging:     https://api.staging.example.com/api/v1
```

#### 1.2 Authentication

All endpoints (except `/auth/*`) require a valid JWT access token in the `Authorization` header:

```
Authorization: Bearer {jwt_access_token}
```

**Token Requirements** (from ADR-005):

| Claim | Type | Required | Description |
|-------|------|----------|-------------|
| `sub` | String | Yes | User ID (e.g., `user_01HQX...`) |
| `iat` | Number | Yes | Issued-at timestamp (Unix seconds) |
| `exp` | Number | Yes | Expiration timestamp (Unix seconds) |
| `jti` | String | Yes | Unique token ID for revocation checking |
| `scope` | String | No | Space-separated scopes (default: `messaging`) |

**Missing/Invalid Token Response:**

```http
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Missing or invalid authentication token",
    "details": {
      "reason": "token_expired"
    }
  }
}
```

#### 1.3 Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| `Authorization` | Yes* | Bearer token (*except auth endpoints) |
| `Content-Type` | Yes** | `application/json` for request bodies (**when body present) |
| `Accept` | No | `application/json` (default) |
| `X-Request-ID` | No | Client-generated request ID for tracing (UUIDv4) |
| `Idempotency-Key` | No | Idempotency key for POST/PATCH (UUIDv4, valid for 24 hours) |
| `X-Device-ID` | Conditional | Device identifier for session binding (see below) |

**X-Device-ID Requirements:**

| Endpoint | X-Device-ID | Behavior |
|----------|-------------|----------|
| `POST /auth/verify-otp` | **Required** | Creates session bound to device |
| `POST /auth/refresh` | **Required** | Must match session's device_id |
| All other authenticated | Optional | Logged for debugging; no enforcement |

**Device ID Change Handling:**

- If `X-Device-ID` on `/auth/refresh` doesn't match the session's bound device_id: **401 `DEVICE_MISMATCH`**
- This prevents token theft: a stolen refresh token cannot be used from a different device
- To switch devices, user must re-authenticate with OTP

#### 1.4 Response Headers

| Header | Always Present | Description |
|--------|----------------|-------------|
| `Content-Type` | Yes | `application/json` |
| `X-Request-ID` | Yes | Echo of client's request ID, or server-generated if not provided |
| `X-RateLimit-Limit` | Yes | Rate limit ceiling for endpoint |
| `X-RateLimit-Remaining` | Yes | Remaining requests in current window |
| `X-RateLimit-Reset` | Yes | Unix timestamp when limit resets |

#### 1.5 Error Response Format

All errors use a consistent envelope. We intentionally chose a custom error format over RFC 7807 (`application/problem+json`) for the following reasons:

1. **Consistency with WebSocket**: The `error` message type in ADR-005 uses `{code, message, details}`. Using the same structure in REST maintains protocol coherence.
2. **Simplicity**: RFC 7807's `type` URI and `instance` fields add complexity without clear benefit for our use cases.
3. **Field-level validation**: Our `field_errors` array provides richer validation feedback than RFC 7807's standard fields.

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable description",
    "details": {
      "field_errors": [
        {
          "field": "content",
          "code": "TOO_LONG",
          "message": "Content must be at most 4096 bytes"
        }
      ]
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `code` | String | Machine-readable error code (see Section 1.6) |
| `message` | String | Human-readable description |
| `details` | Object | Additional context (optional) |
| `details.field_errors` | Array | Validation errors by field (optional) |
| `request_id` | String | Request ID for support/debugging |

#### 1.6 Standard Error Codes

| HTTP Status | Code | Description |
|-------------|------|-------------|
| 400 | `BAD_REQUEST` | Malformed request syntax |
| 400 | `VALIDATION_ERROR` | Request body fails validation |
| 401 | `UNAUTHORIZED` | Missing or invalid authentication |
| 401 | `DEVICE_MISMATCH` | X-Device-ID doesn't match session's device |
| 403 | `FORBIDDEN` | Authenticated but not authorized |
| 403 | `NOT_A_MEMBER` | User is not a member of the chat |
| 404 | `NOT_FOUND` | Resource does not exist |
| 409 | `CONFLICT` | Resource state conflict (e.g., already exists) |
| 409 | `IDEMPOTENCY_KEY_REUSED` | Same key used with different request body |
| 413 | `PAYLOAD_TOO_LARGE` | Request body exceeds limit |
| 422 | `UNPROCESSABLE_ENTITY` | Semantically invalid request |
| 429 | `RATE_LIMITED` | Too many requests |
| 500 | `INTERNAL_ERROR` | Server error |
| 503 | `SERVICE_UNAVAILABLE` | Service temporarily unavailable |

#### 1.7 Request and Response Size Limits

| Limit | Value | Enforcement |
|-------|-------|-------------|
| Request body | 64 KB | 413 `PAYLOAD_TOO_LARGE` |
| Message content | 4,096 bytes | 400 `VALIDATION_ERROR` with field error |
| Chat name | 128 characters | 400 `VALIDATION_ERROR` with field error |
| Display name | 64 characters | 400 `VALIDATION_ERROR` with field error |
| Phone numbers per lookup | 100 | 400 `VALIDATION_ERROR` |
| Response body | 1 MB | Pagination enforced to stay under limit |

**413 Response:**

```http
HTTP/1.1 413 Payload Too Large
Content-Type: application/json
Retry-After: 0

{
  "error": {
    "code": "PAYLOAD_TOO_LARGE",
    "message": "Request body exceeds maximum size of 64KB",
    "details": {
      "max_bytes": 65536,
      "received_bytes": 128000
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

#### 1.8 Pagination

List endpoints use cursor-based pagination:

**Request Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | Integer | 20 | Items per page (max: 100) |
| `cursor` | String | null | Opaque cursor from previous response |
| `direction` | String | `forward` | `forward` or `backward` |

**Response Envelope:**

```json
{
  "data": [...],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJzayI6InVzZXJfMDFIUVguLi4iLCJjayI6ImNoYXRfMDFIUVguLi4ifQ==",
    "prev_cursor": "eyJzayI6InVzZXJfMDFIUVguLi4iLCJjayI6ImNoYXRfMDFIUVguLi4ifQ=="
  }
}
```

**Cursor Structure** (base64-encoded, opaque to clients):

```json
{
  "pk": "partition_key_value",
  "sk": "sort_key_value",
  "v": 1
}
```

#### 1.9 Consistency Model

Different endpoints have different consistency requirements based on their criticality:

| Endpoint Category | Consistency | Rationale |
|-------------------|-------------|-----------|
| **Security-critical reads** | Strongly consistent | Membership checks, authorization |
| `GET /chats/{id}` (membership check) | Strongly consistent | Must not serve stale membership for access control |
| `GET /chats/{id}/messages` | Strongly consistent | Users expect to see their own messages immediately |
| **Non-critical reads** | Eventually consistent | Lower latency, acceptable staleness |
| `GET /chats` (list) | Eventually consistent | Brief staleness in chat list acceptable |
| `GET /users/{id}` | Eventually consistent | Profile data changes infrequently |
| `GET /users/me` | Eventually consistent | User's own profile, rare changes |
| **All writes** | Strongly consistent | Mutations always use consistent reads for validation |

**`updated_since` Parameter Semantics:**

The `updated_since` filter on `GET /chats` uses eventually consistent reads, meaning:
- A chat updated at T may not appear in results for `updated_since < T` until replication completes (typically <1 second)
- Clients should use `updated_since` for efficiency, not correctness
- For guaranteed completeness, omit `updated_since` and paginate through all results

**Read-Your-Own-Writes Guarantee:**

After a successful write operation (POST, PATCH, DELETE), subsequent reads by the same user for the same resource are guaranteed to reflect the write. This is achieved by routing reads to the same DynamoDB partition that processed the write.

#### 1.10 Timestamps

All timestamps are ISO 8601 format in UTC:

```
2026-01-31T10:30:00.000Z
```

#### 1.11 Identifiers

| Entity | Format | Example |
|--------|--------|---------|
| User | ULID with prefix | `user_01HQX7Z9Y8K4M3N2P1Q0R5S6T7` |
| Chat | ULID with prefix | `chat_01HQX7Z9Y8K4M3N2P1Q0R5S6T7` |
| Message | ULID with prefix | `msg_01HQX7Z9Y8K4M3N2P1Q0R5S6T7` |
| Session | ULID with prefix | `sess_01HQX7Z9Y8K4M3N2P1Q0R5S6T7` |

---

### 2. Authentication Endpoints

Authentication uses phone number with OTP verification, as specified in MVP-DEFINITION.md.

#### 2.1 Request OTP

Initiates the authentication flow by sending an OTP to the user's phone.

```
POST /api/v1/auth/request-otp
```

**Request Body:**

```json
{
  "phone_number": "+14155551234"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `phone_number` | String | Yes | E.164 format phone number |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "phone_number": "+14155551234",
    "expires_at": "2026-01-31T10:35:00.000Z",
    "retry_after_seconds": 60
  }
}
```

**Notes:**
- OTP is valid for 5 minutes
- Rate limited: 3 requests per phone number per 15 minutes
- Does not reveal whether phone number is registered

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 400 | `VALIDATION_ERROR` | Invalid phone number format |
| 429 | `RATE_LIMITED` | Too many OTP requests |

#### 2.2 Verify OTP

Verifies the OTP and issues tokens.

```
POST /api/v1/auth/verify-otp
X-Device-ID: {device_id}
```

**Request Body:**

```json
{
  "phone_number": "+14155551234",
  "otp": "123456",
  "device_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `phone_number` | String | Yes | E.164 format phone number |
| `otp` | String | Yes | 6-digit OTP code |
| `device_id` | String | Yes | Client-generated device identifier (UUIDv4) |

**Note:** `device_id` must be provided both in the request body and in the `X-Device-ID` header. They must match.

**Device Binding Semantics:**

The `device_id` is required and creates a binding between the session and the device:
- Each (user, device_id) pair creates a distinct session
- If a user authenticates from the same device_id, the existing session for that device is replaced
- The device_id is stored with the session and used for connection routing (ADR-005)
- Device IDs should be stable across app restarts (stored in secure local storage)

**Success Response (Existing User):**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user": {
      "user_id": "user_01HQX...",
      "phone_number": "+14155551234",
      "display_name": "Alice",
      "created_at": "2026-01-15T08:00:00.000Z"
    },
    "session": {
      "session_id": "sess_01HQX...",
      "device_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2026-01-31T10:30:00.000Z",
      "expires_at": "2026-02-28T10:30:00.000Z"
    },
    "tokens": {
      "access_token": "eyJhbGciOiJSUzI1NiIs...",
      "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4...",
      "token_type": "Bearer",
      "expires_in": 3600
    },
    "is_new_user": false
  }
}
```

**Success Response (New User):**

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "data": {
    "user": {
      "user_id": "user_01HQX...",
      "phone_number": "+14155551234",
      "display_name": null,
      "created_at": "2026-01-31T10:30:00.000Z"
    },
    "session": {
      "session_id": "sess_01HQX...",
      "device_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2026-01-31T10:30:00.000Z",
      "expires_at": "2026-02-28T10:30:00.000Z"
    },
    "tokens": {
      "access_token": "eyJhbGciOiJSUzI1NiIs...",
      "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4...",
      "token_type": "Bearer",
      "expires_in": 3600
    },
    "is_new_user": true
  }
}
```

**Idempotency Semantics for verify-otp:**

Unlike other POST endpoints, `verify-otp` has special idempotency behavior designed to prevent token leakage while allowing safe retries:

| Aspect | Behavior |
|--------|----------|
| **Idempotency Key** | Keyed by `(phone_number, device_id, otp)` tuple, NOT `Idempotency-Key` header |
| **Session** | Same `session_id` returned on repeated successful verifications |
| **Access Token** | **Fresh token minted on each call** (not cached) |
| **Refresh Token** | **Fresh token minted on each call** (not cached) |
| **`is_new_user` flag** | Reflects state at first successful verification |
| **Window** | Valid within OTP validity window (5 minutes) |

**Why fresh tokens on each call?**

Caching tokens introduces security risks:
- If an attacker intercepts a retry, they could obtain the cached tokens
- Token lifetimes would become unpredictable (minted at T1, returned at T2)
- Refresh token rotation becomes ambiguous

Instead, we guarantee:
1. **Same session**: The logical session (`session_id`) is reused
2. **Same outcome**: The operation succeeds with the same side effects (user created/found)
3. **Fresh credentials**: New tokens prevent replay attacks with intercepted responses

This means clients should NOT rely on token values being identical across retries.

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 400 | `VALIDATION_ERROR` | Invalid request format |
| 401 | `INVALID_OTP` | OTP is incorrect or expired |
| 429 | `RATE_LIMITED` | Too many verification attempts |

#### 2.3 Refresh Token

Obtains a new access token using a refresh token.

```
POST /api/v1/auth/refresh
X-Device-ID: {device_id}
```

**Request Body:**

```json
{
  "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4..."
}
```

**Device ID Validation:**

The `X-Device-ID` header must match the device_id bound to the session when it was created. This prevents refresh token theft attacks where an attacker obtains a refresh token but cannot use it from a different device.

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "tokens": {
      "access_token": "eyJhbGciOiJSUzI1NiIs...",
      "refresh_token": "bmV3IHJlZnJlc2ggdG9rZW4...",
      "token_type": "Bearer",
      "expires_in": 3600
    }
  }
}
```

**Notes:**
- Refresh token rotation: new refresh token issued on each use
- Old refresh token invalidated after use
- Refresh token lifetime: 30 days

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 401 | `INVALID_REFRESH_TOKEN` | Token invalid, expired, or already used |
| 401 | `DEVICE_MISMATCH` | X-Device-ID doesn't match session's device |

#### 2.4 Logout

Invalidates the current session and refresh token.

```
POST /api/v1/auth/logout
Authorization: Bearer {access_token}
```

**Request Body:**

```json
{
  "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4..."
}
```

**Success Response:**

```http
HTTP/1.1 204 No Content
```

**Notes:**
- Invalidates the session associated with the refresh token
- Access token remains valid until expiration (short-lived)
- For immediate access token invalidation, use session deletion endpoint

---

### 3. User Endpoints

#### 3.1 Get Current User

Retrieves the authenticated user's profile.

```
GET /api/v1/users/me
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user_id": "user_01HQX...",
    "phone_number": "+14155551234",
    "display_name": "Alice",
    "created_at": "2026-01-15T08:00:00.000Z",
    "updated_at": "2026-01-30T14:00:00.000Z"
  }
}
```

#### 3.2 Update Current User

Updates the authenticated user's profile.

```
PATCH /api/v1/users/me
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "display_name": "Alice Smith"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `display_name` | String | No | Display name (1-64 characters, UTF-8) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user_id": "user_01HQX...",
    "phone_number": "+14155551234",
    "display_name": "Alice Smith",
    "created_at": "2026-01-15T08:00:00.000Z",
    "updated_at": "2026-01-31T10:30:00.000Z"
  }
}
```

**Validation Rules:**

| Field | Rules |
|-------|-------|
| `display_name` | 1-64 characters, no leading/trailing whitespace, no control characters |

#### 3.3 Get User by ID

Retrieves a user's public profile. Used for displaying sender information.

```
GET /api/v1/users/{user_id}
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user_id": "user_01HQX...",
    "display_name": "Bob",
    "created_at": "2026-01-10T12:00:00.000Z"
  }
}
```

**Notes:**
- Returns limited public profile (no phone number)
- Returns 404 if user does not exist

#### 3.4 Lookup Users by Phone Numbers

Finds users by their phone numbers. Used for starting conversations.

```
POST /api/v1/users/lookup
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "phone_numbers": ["+14155551234", "+14155555678", "+14155559999"]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `phone_numbers` | Array | Yes | E.164 format phone numbers (max: 100) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "users": [
      {
        "phone_number": "+14155551234",
        "user_id": "user_01HQX...",
        "display_name": "Alice"
      },
      {
        "phone_number": "+14155555678",
        "user_id": "user_01HQY...",
        "display_name": "Bob"
      }
    ],
    "not_found": ["+14155559999"]
  }
}
```

**Privacy and Enumeration Resistance:**

This endpoint has elevated security considerations because it could be used for contact enumeration attacks:

| Protection | Implementation |
|------------|----------------|
| **Strict rate limiting** | 10 requests/minute per user, 100 requests/hour per user |
| **Batch size limit** | Maximum 100 phone numbers per request |
| **Contact list hashing** (future) | MVP accepts plaintext; future versions will support hashed lookups |
| **Audit logging** | All lookup requests logged with requesting user_id |
| **Abuse detection** | Accounts performing excessive lookups flagged for review |

**Intended Use Case:** This endpoint is designed for contact synchronization when a user first joins or adds contacts. Clients should:
1. Perform initial sync of device contacts on first launch
2. Incrementally sync new contacts only
3. Cache results locally to avoid repeated lookups

**Abuse Patterns Monitored:**
- High volume of lookups with low match rate (fishing for valid numbers)
- Systematic enumeration patterns (sequential numbers)
- Lookups from newly created accounts

**Notes:**
- Only returns users who have verified the phone number
- Rate limited: 10 requests per minute, 100 per hour (per user)
- Maximum 100 phone numbers per request
- `not_found` array intentionally included to support "invite" flows

---

### 4. Chat Endpoints

#### 4.1 Create Chat

Creates a new chat (direct or group).

```
POST /api/v1/chats
Authorization: Bearer {access_token}
Content-Type: application/json
Idempotency-Key: {uuid}
```

**Request Body (Direct Chat):**

```json
{
  "type": "direct",
  "member_ids": ["user_01HQX..."]
}
```

**Request Body (Group Chat):**

```json
{
  "type": "group",
  "name": "Project Team",
  "member_ids": ["user_01HQX...", "user_01HQY...", "user_01HQZ..."]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | String | Yes | `direct` or `group` |
| `name` | String | No* | Chat name (*required for group, ignored for direct) |
| `member_ids` | Array | Yes | User IDs to add (excluding self) |

**Success Response:**

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "type": "group",
    "name": "Project Team",
    "created_by": "user_01ABC...",
    "created_at": "2026-01-31T10:30:00.000Z",
    "updated_at": "2026-01-31T10:30:00.000Z",
    "members": [
      {
        "user_id": "user_01ABC...",
        "role": "owner",
        "display_name": "Alice",
        "joined_at": "2026-01-31T10:30:00.000Z"
      },
      {
        "user_id": "user_01HQX...",
        "role": "member",
        "display_name": "Bob",
        "joined_at": "2026-01-31T10:30:00.000Z"
      }
    ],
    "member_count": 2
  }
}
```

**Direct Chat Semantics:**

- `member_ids` must contain exactly one user ID (the other participant)
- **Uniqueness enforcement**: Direct chats are unique per participant pair
- **Canonicalization**: member_ids are sorted lexicographically to ensure `{A, B}` and `{B, A}` map to the same chat
- **Idempotent creation**: If a direct chat already exists between the two users:
  - Returns **200 OK** with the existing chat (not 409)
  - This is intentional: clients should be able to call "create direct chat" without checking existence first
  - The `X-Idempotent-Replay: true` header is set to indicate this was not a new creation
- Direct chats cannot be renamed
- Direct chats have no owner (both users are `member` role)

**Group Chat Semantics:**

- `member_ids` can contain 1-99 user IDs (creator is automatically added)
- Creator becomes `owner`
- All other members become `member`
- Maximum group size: 100 members
- Group chats are never deduplicated (same members can be in multiple groups)

**Validation Rules:**

| Field | Rules |
|-------|-------|
| `type` | Must be `direct` or `group` |
| `name` | 1-128 characters for groups; ignored for direct |
| `member_ids` | 1-99 valid user IDs; cannot include self |

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 400 | `VALIDATION_ERROR` | Invalid request format |
| 404 | `USER_NOT_FOUND` | One or more member_ids do not exist |

> **Note**: There is no `CHAT_EXISTS` error for direct chats. Existing direct chats return 200 OK with the existing chat data. This design choice prioritizes client simplicity over strict REST semantics.

#### 4.2 List Chats

Retrieves the authenticated user's chats.

```
GET /api/v1/chats
Authorization: Bearer {access_token}
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | Integer | 20 | Items per page (max: 100) |
| `cursor` | String | null | Pagination cursor |
| `updated_since` | String | null | ISO 8601 timestamp filter |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    {
      "chat_id": "chat_01HQX...",
      "type": "group",
      "name": "Project Team",
      "created_at": "2026-01-15T08:00:00.000Z",
      "updated_at": "2026-01-31T10:00:00.000Z",
      "member_count": 5,
      "my_membership": {
        "role": "member",
        "joined_at": "2026-01-15T08:00:00.000Z",
        "muted_until": null
      },
      "last_message": {
        "message_id": "msg_01HQX...",
        "sequence": 147,
        "sender_id": "user_01HQY...",
        "content_preview": "Hey everyone, the meeting is...",
        "created_at": "2026-01-31T10:00:00.000Z"
      },
      "pending_ack_count": 3
    },
    {
      "chat_id": "chat_01HQY...",
      "type": "direct",
      "name": null,
      "created_at": "2026-01-20T14:00:00.000Z",
      "updated_at": "2026-01-30T16:00:00.000Z",
      "member_count": 2,
      "other_member": {
        "user_id": "user_01HQZ...",
        "display_name": "Carol"
      },
      "my_membership": {
        "role": "member",
        "joined_at": "2026-01-20T14:00:00.000Z",
        "muted_until": null
      },
      "last_message": {
        "message_id": "msg_01HQY...",
        "sequence": 42,
        "sender_id": "user_01HQZ...",
        "content_preview": "See you tomorrow!",
        "created_at": "2026-01-30T16:00:00.000Z"
      },
      "pending_ack_count": 0
    }
  ],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJzayI6...",
    "prev_cursor": null
  }
}
```

**Notes:**

- `content_preview` is truncated to 100 characters
- `pending_ack_count` = `chat.current_sequence - user.last_acked_sequence`
  - This represents messages **delivered to the chat but not yet acknowledged by this client**
  - This is NOT "unread count" (read receipts are out of scope for MVP per MVP-DEFINITION.md)
  - A value of 3 means: "3 messages exist that this client hasn't acknowledged receiving"
  - After WebSocket sync completes and client sends `ack`, this resets to 0
- For direct chats, `other_member` provides the other participant's info
- Results ordered by `updated_at` descending (most recent first)

#### 4.3 Get Chat

Retrieves a specific chat's details.

```
GET /api/v1/chats/{chat_id}
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "type": "group",
    "name": "Project Team",
    "created_by": "user_01ABC...",
    "created_at": "2026-01-15T08:00:00.000Z",
    "updated_at": "2026-01-31T10:00:00.000Z",
    "members": [
      {
        "user_id": "user_01ABC...",
        "role": "owner",
        "display_name": "Alice",
        "joined_at": "2026-01-15T08:00:00.000Z"
      },
      {
        "user_id": "user_01HQX...",
        "role": "admin",
        "display_name": "Bob",
        "joined_at": "2026-01-15T08:00:00.000Z"
      },
      {
        "user_id": "user_01HQY...",
        "role": "member",
        "display_name": "Carol",
        "joined_at": "2026-01-20T14:00:00.000Z"
      }
    ],
    "member_count": 3,
    "current_sequence": 147,
    "my_membership": {
      "role": "member",
      "joined_at": "2026-01-20T14:00:00.000Z",
      "muted_until": null,
      "last_acked_sequence": 144
    }
  }
}
```

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 403 | `NOT_A_MEMBER` | User is not a member of the chat |
| 404 | `NOT_FOUND` | Chat does not exist |

#### 4.4 Update Chat

Updates a chat's metadata (group chats only).

```
PATCH /api/v1/chats/{chat_id}
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "name": "Updated Project Team Name"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | String | No | New chat name (1-128 characters) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "type": "group",
    "name": "Updated Project Team Name",
    "created_by": "user_01ABC...",
    "created_at": "2026-01-15T08:00:00.000Z",
    "updated_at": "2026-01-31T10:35:00.000Z",
    "member_count": 3
  }
}
```

**Authorization:**

- `owner` and `admin` can update chat metadata
- `member` cannot update chat metadata
- Direct chats cannot be updated

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 403 | `FORBIDDEN` | User lacks permission to update |
| 403 | `NOT_A_MEMBER` | User is not a member of the chat |
| 400 | `INVALID_OPERATION` | Cannot update direct chat |

#### 4.5 Add Chat Member

Adds a user to a group chat.

```
POST /api/v1/chats/{chat_id}/members
Authorization: Bearer {access_token}
Content-Type: application/json
Idempotency-Key: {uuid}
```

**Request Body:**

```json
{
  "user_id": "user_01HQZ...",
  "role": "member"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `user_id` | String | Yes | User ID to add |
| `role` | String | No | Role: `member` (default) or `admin` |

**Success Response:**

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "user_id": "user_01HQZ...",
    "role": "member",
    "display_name": "Dave",
    "joined_at": "2026-01-31T10:40:00.000Z",
    "added_by": "user_01ABC..."
  }
}
```

**Authorization:**

- `owner` can add members with any role
- `admin` can add members with `member` role only
- `member` cannot add members
- Cannot add members to direct chats

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 403 | `FORBIDDEN` | User lacks permission to add members |
| 404 | `USER_NOT_FOUND` | User to add does not exist |
| 409 | `ALREADY_A_MEMBER` | User is already a member |
| 400 | `INVALID_OPERATION` | Cannot add members to direct chat |
| 400 | `CHAT_FULL` | Chat has reached maximum member limit (100) |

#### 4.6 Remove Chat Member

Removes a user from a group chat.

```
DELETE /api/v1/chats/{chat_id}/members/{user_id}
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 204 No Content
```

**Authorization:**

- `owner` can remove anyone except themselves
- `admin` can remove `member` role users only
- `member` cannot remove others
- Cannot remove from direct chats
- To remove self, use `/chats/{id}/leave` instead

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 403 | `FORBIDDEN` | User lacks permission to remove |
| 400 | `INVALID_OPERATION` | Cannot remove self (use leave), cannot remove owner |

#### 4.7 Update Member Role

Updates a member's role in a group chat.

```
PATCH /api/v1/chats/{chat_id}/members/{user_id}
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "role": "admin"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | String | Yes | New role: `member` or `admin` |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "user_id": "user_01HQY...",
    "role": "admin",
    "display_name": "Bob",
    "joined_at": "2026-01-15T08:00:00.000Z",
    "updated_by": "user_01ABC..."
  }
}
```

**Authorization:**

- Only `owner` can change roles
- Cannot change own role
- Cannot assign `owner` role (ownership transfer not supported in MVP)

#### 4.8 Leave Chat

Allows a user to leave a group chat.

```
POST /api/v1/chats/{chat_id}/leave
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 204 No Content
```

**Semantics:**

- User is removed from the chat
- For group chats: user's messages remain in history
- For direct chats: not allowed (use mute instead)
- Owner cannot leave without transferring ownership first (MVP: ownership transfer not supported, so owner cannot leave)

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 400 | `INVALID_OPERATION` | Cannot leave direct chat; owner cannot leave group |

#### 4.9 Mute Chat

Mutes notifications for a chat.

```
POST /api/v1/chats/{chat_id}/mute
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "duration_hours": 24
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `duration_hours` | Integer | No | Mute duration in hours (null = indefinite, max: 8760 = 1 year) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "muted_until": "2026-02-01T10:45:00.000Z"
  }
}
```

#### 4.10 Unmute Chat

Unmutes a chat.

```
POST /api/v1/chats/{chat_id}/unmute
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "muted_until": null
  }
}
```

---

### 5. Message Endpoints

Message sending occurs over WebSocket (ADR-005). REST APIs provide history retrieval and message lookup.

#### 5.0 Membership and History Access Policy

**Current Members:** Full access to all messages in the chat, including messages sent before they joined.

**Ex-Members (removed or left):** 
- **Cannot access message history** via REST API (returns 403 `NOT_A_MEMBER`)
- Their sent messages remain visible to current members
- This is a deliberate privacy choice: leaving a chat revokes access to the conversation

**Rationale:** This matches user expectations from consumer messaging apps (WhatsApp, iMessage). Alternative designs (retaining read access to messages up to departure time) add complexity and may violate privacy expectations.

#### 5.1 Get Messages (History)

Retrieves message history for a chat.

```
GET /api/v1/chats/{chat_id}/messages
Authorization: Bearer {access_token}
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | Integer | 50 | Messages per page (max: 100) |
| `cursor` | String | null | Pagination cursor |
| `direction` | String | `backward` | `forward` (ascending) or `backward` (descending) |
| `before_sequence` | Integer | null | Return messages with sequence < value |
| `after_sequence` | Integer | null | Return messages with sequence > value |

**Parameter Exclusivity:**

| Combination | Behavior |
|-------------|----------|
| `cursor` only | Standard pagination |
| `before_sequence` only | Messages with seq < value, ordered per `direction` |
| `after_sequence` only | Messages with seq > value, ordered per `direction` |
| `cursor` + `before_sequence` | **400 Error**: mutually exclusive |
| `cursor` + `after_sequence` | **400 Error**: mutually exclusive |
| `before_sequence` + `after_sequence` | Valid: returns messages in range (exclusive both ends) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    {
      "message_id": "msg_01HQX...",
      "chat_id": "chat_01HQX...",
      "sequence": 147,
      "sender_id": "user_01HQY...",
      "sender": {
        "user_id": "user_01HQY...",
        "display_name": "Bob"
      },
      "content": "Hey everyone, the meeting is moved to 3pm.",
      "content_type": "text/plain",
      "created_at": "2026-01-31T10:00:00.000Z"
    },
    {
      "message_id": "msg_01HQW...",
      "chat_id": "chat_01HQX...",
      "sequence": 146,
      "sender_id": "user_01ABC...",
      "sender": {
        "user_id": "user_01ABC...",
        "display_name": "Alice"
      },
      "content": "Got it, thanks!",
      "content_type": "text/plain",
      "created_at": "2026-01-31T09:55:00.000Z"
    }
  ],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJzZXEiOjE0NX0=",
    "prev_cursor": "eyJzZXEiOjE0OH0="
  }
}
```

**Message Ordering Guarantees:**

| Guarantee | Description |
|-----------|-------------|
| **Strict monotonicity within page** | Messages in `data` array are strictly ordered by `sequence` (no ties, no out-of-order) |
| **Direction determines order** | `backward`: descending (147, 146, 145...); `forward`: ascending (145, 146, 147...) |
| **No duplicates across pages** | Following cursors will never return a message already seen (given stable cursor) |
| **Gaps are preserved** | If sequences 145, 147 exist but 146 doesn't (gap from failed write), response shows [147, 145] |
| **Cursor stability** | Cursors remain valid even as new messages are added; new messages appear in subsequent pages |

**Formal Ordering Invariants:**

```
INVARIANT page_monotonicity:
  ∀ page P with direction = backward:
    ∀ i < j: P.data[i].sequence > P.data[j].sequence
  ∀ page P with direction = forward:
    ∀ i < j: P.data[i].sequence < P.data[j].sequence

INVARIANT no_duplicate_across_cursor:
  ∀ cursor C, pages P1 = fetch(C), P2 = fetch(P1.next_cursor):
    P1.data ∩ P2.data = ∅  (by message_id)

INVARIANT cursor_sequence_boundary:
  ∀ page P with direction = backward:
    P.next_cursor encodes sequence S where S < min(P.data[*].sequence)
  ∀ page P with direction = forward:
    P.next_cursor encodes sequence S where S > max(P.data[*].sequence)
```

**Default Behavior:**

- `direction=backward` returns messages in descending sequence order (newest first)
- This matches typical chat UI where latest messages appear at bottom
- Client scrolls up to load older messages

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 400 | `VALIDATION_ERROR` | Invalid parameter combination (cursor + sequence filter) |
| 403 | `NOT_A_MEMBER` | User is not a current member of the chat |
| 404 | `NOT_FOUND` | Chat does not exist |

#### 5.2 Get Message by ID

Retrieves a specific message.

```
GET /api/v1/chats/{chat_id}/messages/{message_id}
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "message_id": "msg_01HQX...",
    "chat_id": "chat_01HQX...",
    "sequence": 147,
    "sender_id": "user_01HQY...",
    "sender": {
      "user_id": "user_01HQY...",
      "display_name": "Bob"
    },
    "content": "Hey everyone, the meeting is moved to 3pm.",
    "content_type": "text/plain",
    "created_at": "2026-01-31T10:00:00.000Z"
  }
}
```

**Error Responses:**

| Status | Code | Condition |
|--------|------|-----------|
| 403 | `NOT_A_MEMBER` | User is not a member of the chat |
| 404 | `NOT_FOUND` | Message does not exist |

#### 5.3 Get Messages Around Sequence

Retrieves messages surrounding a specific sequence number. Useful for "jump to message" functionality.

```
GET /api/v1/chats/{chat_id}/messages/around/{sequence}
Authorization: Bearer {access_token}
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `context` | Integer | 25 | Messages to return on each side (max: 50) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "target_sequence": 147,
    "messages": [
      {"sequence": 122, ...},
      {"sequence": 123, ...},
      ...
      {"sequence": 147, ...},
      ...
      {"sequence": 171, ...},
      {"sequence": 172, ...}
    ],
    "has_more_before": true,
    "has_more_after": false
  }
}
```

---

### 6. Session Endpoints

Sessions represent authenticated devices. A user may have multiple concurrent sessions.

#### 6.1 List Sessions

Retrieves all active sessions for the authenticated user.

```
GET /api/v1/sessions
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    {
      "session_id": "sess_01HQX...",
      "device_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2026-01-31T10:30:00.000Z",
      "last_active_at": "2026-01-31T10:45:00.000Z",
      "expires_at": "2026-02-28T10:30:00.000Z",
      "is_current": true
    },
    {
      "session_id": "sess_01HQY...",
      "device_id": "660e8400-e29b-41d4-a716-446655440001",
      "created_at": "2026-01-25T08:00:00.000Z",
      "last_active_at": "2026-01-30T16:00:00.000Z",
      "expires_at": "2026-02-24T08:00:00.000Z",
      "is_current": false
    }
  ]
}
```

**Notes:**

- `is_current` indicates the session making this request
- `last_active_at` updated on token refresh and API activity

#### 6.2 Revoke Session

Revokes a specific session.

```
DELETE /api/v1/sessions/{session_id}
Authorization: Bearer {access_token}
```

**Success Response:**

```http
HTTP/1.1 204 No Content
```

**Notes:**

- Can revoke any session belonging to the user
- Revoking current session is allowed (logs out this device)
- Associated WebSocket connections will be terminated

#### 6.3 Revoke All Sessions

Revokes all sessions except the current one.

```
DELETE /api/v1/sessions
Authorization: Bearer {access_token}
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `include_current` | Boolean | false | Also revoke current session |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "revoked_count": 3
  }
}
```

---

### 7. Delivery State Endpoints

Delivery state tracks which messages a user has received. This is separate from read receipts (out of MVP scope).

#### 7.1 Get Delivery State

Retrieves delivery state for the user's chats.

```
GET /api/v1/delivery-state
Authorization: Bearer {access_token}
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `chat_ids` | String | null | Comma-separated chat IDs (max: 50) |

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    {
      "chat_id": "chat_01HQX...",
      "last_acked_sequence": 144,
      "current_sequence": 147,
      "unread_count": 3,
      "updated_at": "2026-01-31T09:30:00.000Z"
    },
    {
      "chat_id": "chat_01HQY...",
      "last_acked_sequence": 42,
      "current_sequence": 42,
      "unread_count": 0,
      "updated_at": "2026-01-30T16:00:00.000Z"
    }
  ]
}
```

**Notes:**

- If `chat_ids` not specified, returns state for all user's chats
- `current_sequence` is the latest message sequence in the chat
- `unread_count` = `current_sequence` - `last_acked_sequence`

#### 7.2 Update Delivery State

Updates delivery state (typically used when viewing chat on web when WebSocket not connected).

```
PATCH /api/v1/delivery-state/{chat_id}
Authorization: Bearer {access_token}
Content-Type: application/json
```

**Request Body:**

```json
{
  "last_acked_sequence": 147
}
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQX...",
    "last_acked_sequence": 147,
    "updated_at": "2026-01-31T10:50:00.000Z"
  }
}
```

**Notes:**

- Sequence can only move forward (cannot decrease)
- Typically used by REST clients; WebSocket clients use `ack` message (ADR-005)

---

### 8. Health and Metadata Endpoints

#### 8.1 Health Check

Simple health check for load balancers.

```
GET /api/v1/health
```

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "healthy",
  "timestamp": "2026-01-31T10:50:00.000Z"
}
```

**No authentication required.**

#### 8.2 API Version and Capabilities

Returns API version and system-wide capabilities. This endpoint is **public** (no authentication required) because clients may need to check capabilities before authenticating (e.g., to determine supported auth methods or API version compatibility).

```
GET /api/v1/
```

**No authentication required.**

**Success Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "version": "1.0.0",
    "api_version": "v1",
    "capabilities": {
      "max_message_size_bytes": 4096,
      "max_chat_members": 100,
      "max_chats_per_user": 1000,
      "supported_content_types": ["text/plain"],
      "auth_methods": ["phone_otp"],
      "websocket_protocol_version": 1
    },
    "documentation_url": "https://docs.example.com/api/v1"
  }
}
```

**Note:** For user-specific limits (if they differ from defaults), clients should query `GET /users/me` after authentication.

---

### 9. Rate Limiting

#### 9.1 Rate Limit Keys

Rate limits are applied using different keys depending on the endpoint category:

| Endpoint Category | Rate Limit Key | Rationale |
|-------------------|----------------|-----------|
| `/auth/request-otp` | Phone number (hashed) | Prevent OTP spam to specific numbers |
| `/auth/verify-otp` | Phone number (hashed) | Prevent brute-force OTP guessing |
| `/auth/refresh` | User ID | Post-auth, user identity is known |
| `/users/lookup` | User ID | Prevent contact enumeration |
| All other authenticated | User ID | Standard per-user limiting |
| Unauthenticated (except auth) | IP address | Fallback for abuse prevention |

**NAT and Shared IP Considerations:**

- IP-based limits are set conservatively high to avoid blocking users behind corporate NATs
- For auth endpoints, phone number is the primary key (IP is secondary)
- Authenticated endpoints use user ID exclusively (IP is not considered)
- If legitimate users report rate limiting, we may implement device fingerprinting (future)

#### 9.2 Rate Limit Tiers

| Tier | Endpoints | Limit | Window | Key |
|------|-----------|-------|--------|-----|
| Auth | `/auth/request-otp` | 3 | 15 minutes | phone |
| Auth | `/auth/verify-otp` | 5 | 5 minutes | phone |
| Auth | `/auth/refresh` | 30 | 1 minute | user_id |
| Read | GET endpoints | 300 | 1 minute | user_id |
| Write | POST/PATCH/DELETE | 60 | 1 minute | user_id |
| Lookup | `/users/lookup` | 10/min, 100/hour | sliding | user_id |

#### 9.3 Rate Limit Headers

All responses include rate limit headers:

```http
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 45
X-RateLimit-Reset: 1706698260
```

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests allowed in the window |
| `X-RateLimit-Remaining` | Requests remaining in current window |
| `X-RateLimit-Reset` | Unix timestamp when the window resets |
| `Retry-After` | Seconds until requests will be accepted (**only on 429 responses**) |

**Note:** `Retry-After` is included on ALL 429 responses, not just some.

#### 9.4 Rate Limit Exceeded Response

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 30
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1706698260

{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Rate limit exceeded. Please retry after 30 seconds.",
    "details": {
      "limit": 60,
      "window_seconds": 60,
      "retry_after_seconds": 30
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

---

### 10. Idempotency

#### 10.1 Idempotent Operations

The following operations support idempotency via the `Idempotency-Key` header:

| Endpoint | Idempotency Behavior |
|----------|---------------------|
| `POST /chats` | Returns existing chat if created with same key |
| `POST /chats/{id}/members` | Returns existing membership if added with same key |
| `POST /auth/verify-otp` | Special handling: keyed by `(phone, device_id, otp)`, NOT `Idempotency-Key` header (see Section 2.2) |

#### 10.2 Idempotency Key Requirements

| Requirement | Value | Notes |
|-------------|-------|-------|
| Format | UUIDv4 | Cryptographically random |
| Lifetime | 24 hours | Keys expire 24 hours after first use |
| Scope | Per-user | Same key from different users creates separate operations |
| Storage | Server-side | Keys stored in DynamoDB with TTL |

**Key Collision Handling:**

If the same `Idempotency-Key` is used with:
- **Same endpoint + same request body**: Returns cached response (replay)
- **Same endpoint + different request body**: Returns 409 `CONFLICT` with error `IDEMPOTENCY_KEY_REUSED`
- **Different endpoint**: Creates separate operation (keys are endpoint-scoped)

#### 10.3 Idempotency Replay Semantics

When a duplicate request is detected:

```http
HTTP/1.1 200 OK
Content-Type: application/json
X-Idempotent-Replay: true

{
  "data": {
    // Response body is reconstructed, not cached verbatim
  }
}
```

**What is cached vs. reconstructed:**

| Aspect | Behavior |
|--------|----------|
| **Status code** | Cached (original status returned) |
| **Created resource IDs** | Cached (same `chat_id`, `session_id`, etc.) |
| **Response body** | Reconstructed by querying current state |
| **Timestamps** | Reflect current query time, not original creation time |
| **Side effects** | Never re-executed (no duplicate Kafka events, etc.) |

**Rationale for reconstruction:**

Caching full response bodies for 24 hours is expensive and complex. Instead, we cache only the operation outcome (success/failure + created resource IDs) and reconstruct the response body on replay. This means:

1. Replays return current state of the resource, not the exact original response
2. If a resource was modified between original request and replay, the replay shows the current state
3. This is acceptable because idempotency guarantees "same operation outcome," not "byte-identical response"

**Example: Chat Creation Replay**

```
Original request:   POST /chats with Idempotency-Key: abc123
Original response:  201 Created, chat_id: chat_01HQX..., member_count: 3

[Later, a member is added to the chat]

Replay request:     POST /chats with Idempotency-Key: abc123
Replay response:    200 OK, chat_id: chat_01HQX..., member_count: 4
                    X-Idempotent-Replay: true
```

The `X-Idempotent-Replay: true` header indicates this is a replayed response.

---

### 11. Webhooks (Future Consideration)

> **MVP Scope Note**: Webhooks are **out of scope** for MVP. This section documents the intended design for future implementation.

For server-to-server integrations, the system will support webhooks for events:

- `chat.created`
- `chat.updated`
- `member.added`
- `member.removed`
- `message.created`

Webhook configuration will be available via:

```
POST /api/v1/webhooks
GET /api/v1/webhooks
DELETE /api/v1/webhooks/{webhook_id}
```

---

## Consequences

### Positive Consequences

1. **Consistency with WebSocket Protocol**: Shared schemas and naming conventions reduce cognitive load and implementation errors.

2. **Clear Authorization Model**: Every endpoint has explicit permission requirements documented.

3. **Pagination by Design**: Cursor-based pagination prevents the "page drift" problem and aligns with DynamoDB access patterns.

4. **Idempotency Support**: Retry-safe operations for unreliable networks.

5. **Comprehensive Error Handling**: Consistent error format enables automated error handling in clients.

6. **Mobile-Friendly**: Minimal round trips, efficient payloads, rate limiting that accommodates mobile usage patterns.

### Negative Consequences

1. **API Surface Complexity**: Many endpoints to implement and maintain.
   *Mitigation*: Clear organization by domain; consistent patterns reduce per-endpoint complexity.

2. **Versioning Overhead**: Version in URL requires managing multiple API versions.
   *Mitigation*: Commit to backward compatibility within major versions; deprecation policy.

3. **REST Limitations**: Some operations don't map cleanly to CRUD.
   *Mitigation*: Pragmatic deviations (e.g., `/leave` action endpoint).

4. **Duplication with WebSocket**: Some operations available via both protocols.
   *Mitigation*: Clear guidance on when to use each; REST for management, WebSocket for real-time.

---

## Confirmation

The implementation of this ADR will be validated through:

1. **Schema Validation Tests**: OpenAPI spec compliance for all endpoints.

2. **Authentication Tests**:
   - Missing token → 401
   - Expired token → 401
   - Invalid token → 401
   - Valid token → success

3. **Authorization Tests**:
   - Member accessing chat → success
   - Non-member accessing chat → 403
   - Member adding member → 403 (insufficient permission)
   - Admin adding member → success

4. **Pagination Tests**:
   - Cursor stability across pages
   - Empty pages handled correctly
   - Limit parameter respected

5. **Idempotency Tests**:
   - Duplicate request with same key → same response
   - Request after key expiration → treated as new request

6. **Rate Limiting Tests**:
   - Requests within limit → success
   - Requests exceeding limit → 429
   - Rate limit headers present

7. **Error Format Tests**:
   - All errors match documented format
   - Field-level validation errors included

8. **Integration Tests**:
   - Full flow: auth → create chat → add member → fetch messages
   - REST + WebSocket interop: create via REST, receive via WebSocket

---

## Pros and Cons of the Options

### Option 1: Pure REST (Resource-Oriented)

| Aspect | Assessment |
|--------|------------|
| Good | Highly predictable and standardized |
| Good | Works well with API tooling |
| Bad | Some operations don't map to CRUD (e.g., "leave chat") |
| Bad | Deeply nested URLs become unwieldy |

### Option 2: GraphQL

| Aspect | Assessment |
|--------|------------|
| Good | Flexible queries, no over-fetching |
| Good | Single endpoint simplifies routing |
| Bad | Complexity overhead for simple operations |
| Bad | Caching more difficult |
| Bad | Learning curve for team and consumers |

### Option 3: RPC-Style (Action-Oriented)

| Aspect | Assessment |
|--------|------------|
| Good | Clear action semantics |
| Good | No resource mapping constraints |
| Bad | Less predictable structure |
| Bad | Poor fit with standard HTTP tooling |
| Bad | Harder to cache |

### Option 4: Hybrid REST with Pragmatic Deviations (CHOSEN)

| Aspect | Assessment |
|--------|------------|
| Good | Predictable for standard operations |
| Good | Flexibility for complex operations |
| Good | Works with standard tooling |
| Good | Familiar to most developers |
| Neutral | Some subjectivity in when to deviate |

---

## DynamoDB Access Pattern Mapping

> **Complete Reference**: For the comprehensive access pattern matrix, table schemas, and GSI configurations, see **[ADR-007: Data Model and Index Strategy](./ADR-007.md#4-access-pattern-quick-reference)**.

This section provides a summary mapping of REST endpoints to DynamoDB operations, demonstrating that the API contract is directly implementable against the defined data model.

### Key Endpoint Mappings

| Endpoint Category | Primary Table(s) | Notes |
|-------------------|------------------|-------|
| Authentication (`/auth/*`) | `users`, `sessions` | Phone lookup via GSI, session CRUD |
| Users (`/users/*`) | `users` | Direct key access by `user_id` |
| Chats (`/chats/*`) | `chats`, `chat_memberships`, `chat_counters` | Transactional creates; GSI for user's chat list |
| Messages (`/chats/{id}/messages`) | `messages` | Range queries on `sequence` sort key |
| Delivery State (`/delivery-state/*`) | `delivery_state` | User-centric partitioning |
| Sessions (`/sessions/*`) | `sessions` | GSI for user's session list |

### Query Alignment Notes

- **Message History**: Maps directly to DynamoDB Query with `ScanIndexForward=false` for descending order
- **Chat List**: Uses `user_chats-index` GSI; `updated_since` filter applied post-query
- **User Lookup**: BatchGetItem on `phone_number-index` GSI (max 100 items per request)

---

## More Information

### Related Patterns and Prior Art

1. **Stripe API**: Exemplary REST API design with consistent error formats, idempotency keys, and expansion parameters.

2. **Slack Web API**: Hybrid approach with REST-like endpoints and action-specific operations.

3. **Discord API**: Resource-oriented with clear rate limiting and permission model.

4. **GitHub API**: Well-documented REST API with pagination, rate limiting, and conditional requests.

### References

- Fielding, R. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. Doctoral dissertation.
- Masse, M. (2011). *REST API Design Rulebook*. O'Reilly Media.
- RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
- RFC 7807: Problem Details for HTTP APIs

### Future Considerations

1. **ADR-XXX: Batch Operations**: Batch endpoints for bulk operations (create multiple chats, add multiple members).

2. **ADR-XXX: Partial Responses**: Field selection to reduce payload size (`?fields=id,name`).

3. **ADR-XXX: Conditional Requests**: ETag and If-None-Match for efficient caching.

4. **ADR-XXX: Search API**: Full-text search across messages.

5. **ADR-XXX: Admin API**: Administrative operations for user management, moderation.

---

## Appendix A: OpenAPI Specification Summary

```yaml
openapi: 3.0.3
info:
  title: Messaging Platform API
  version: 1.0.0
  description: REST API for chat management and message history

servers:
  - url: https://api.example.com/api/v1
    description: Production
  - url: https://api.staging.example.com/api/v1
    description: Staging

security:
  - bearerAuth: []

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    Error:
      type: object
      required: [error]
      properties:
        error:
          type: object
          required: [code, message]
          properties:
            code:
              type: string
            message:
              type: string
            details:
              type: object
            request_id:
              type: string

    User:
      type: object
      required: [user_id]
      properties:
        user_id:
          type: string
        phone_number:
          type: string
        display_name:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    Chat:
      type: object
      required: [chat_id, type, created_at]
      properties:
        chat_id:
          type: string
        type:
          type: string
          enum: [direct, group]
        name:
          type: string
        created_by:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
        member_count:
          type: integer

    Message:
      type: object
      required: [message_id, chat_id, sequence, sender_id, content, created_at]
      properties:
        message_id:
          type: string
        chat_id:
          type: string
        sequence:
          type: integer
        sender_id:
          type: string
        content:
          type: string
        content_type:
          type: string
        created_at:
          type: string
          format: date-time

    Pagination:
      type: object
      properties:
        has_more:
          type: boolean
        next_cursor:
          type: string
        prev_cursor:
          type: string

paths:
  /auth/request-otp:
    post:
      summary: Request OTP
      tags: [Authentication]
      security: []
      # ... full spec continues

  /chats:
    get:
      summary: List chats
      tags: [Chats]
      # ...
    post:
      summary: Create chat
      tags: [Chats]
      # ...

  /chats/{chat_id}/messages:
    get:
      summary: Get message history
      tags: [Messages]
      # ...
```

*Full OpenAPI specification available at `/api/v1/openapi.yaml`*

---

## Appendix B: Request/Response Examples

### B.1 Complete Authentication Flow

```http
# Step 1: Request OTP
POST /api/v1/auth/request-otp HTTP/1.1
Host: api.example.com
Content-Type: application/json

{"phone_number": "+14155551234"}

# Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "phone_number": "+14155551234",
    "expires_at": "2026-01-31T10:35:00.000Z",
    "retry_after_seconds": 60
  }
}
```

```http
# Step 2: Verify OTP
POST /api/v1/auth/verify-otp HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "phone_number": "+14155551234",
  "otp": "123456",
  "device_id": "550e8400-e29b-41d4-a716-446655440000"
}

# Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": {
    "user": {
      "user_id": "user_01HQX...",
      "phone_number": "+14155551234",
      "display_name": "Alice",
      "created_at": "2026-01-15T08:00:00.000Z"
    },
    "session": {
      "session_id": "sess_01HQX...",
      "device_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2026-01-31T10:30:00.000Z",
      "expires_at": "2026-02-28T10:30:00.000Z"
    },
    "tokens": {
      "access_token": "eyJhbGciOiJSUzI1NiIs...",
      "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4...",
      "token_type": "Bearer",
      "expires_in": 3600
    },
    "is_new_user": false
  }
}
```

### B.2 Create and Manage Group Chat

```http
# Create group chat
POST /api/v1/chats HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json
Idempotency-Key: 550e8400-e29b-41d4-a716-446655440001

{
  "type": "group",
  "name": "Project Team",
  "member_ids": ["user_01HQX...", "user_01HQY..."]
}

# Response
HTTP/1.1 201 Created
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQZ...",
    "type": "group",
    "name": "Project Team",
    "created_by": "user_01ABC...",
    "created_at": "2026-01-31T10:30:00.000Z",
    "members": [
      {"user_id": "user_01ABC...", "role": "owner", "display_name": "Alice"},
      {"user_id": "user_01HQX...", "role": "member", "display_name": "Bob"},
      {"user_id": "user_01HQY...", "role": "member", "display_name": "Carol"}
    ],
    "member_count": 3
  }
}
```

```http
# Add another member
POST /api/v1/chats/chat_01HQZ.../members HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json
Idempotency-Key: 550e8400-e29b-41d4-a716-446655440002

{
  "user_id": "user_01HQW...",
  "role": "member"
}

# Response
HTTP/1.1 201 Created
Content-Type: application/json

{
  "data": {
    "chat_id": "chat_01HQZ...",
    "user_id": "user_01HQW...",
    "role": "member",
    "display_name": "Dave",
    "joined_at": "2026-01-31T10:35:00.000Z",
    "added_by": "user_01ABC..."
  }
}
```

### B.3 Fetch Message History with Pagination

```http
# First page (most recent)
GET /api/v1/chats/chat_01HQZ.../messages?limit=20 HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...

# Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    {
      "message_id": "msg_01HQX...",
      "chat_id": "chat_01HQZ...",
      "sequence": 147,
      "sender_id": "user_01HQY...",
      "sender": {"user_id": "user_01HQY...", "display_name": "Bob"},
      "content": "Meeting moved to 3pm",
      "content_type": "text/plain",
      "created_at": "2026-01-31T10:00:00.000Z"
    },
    // ... 19 more messages
  ],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJzZXEiOjEyN30=",
    "prev_cursor": null
  }
}
```

```http
# Second page (older messages)
GET /api/v1/chats/chat_01HQZ.../messages?limit=20&cursor=eyJzZXEiOjEyN30= HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...

# Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": [
    // Messages with sequence 127-108
  ],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJzZXEiOjEwN30=",
    "prev_cursor": "eyJzZXEiOjEyOH0="
  }
}
```

---

## Appendix C: Error Response Examples

### C.1 Validation Error

```http
POST /api/v1/chats HTTP/1.1
Content-Type: application/json

{
  "type": "group",
  "name": "",
  "member_ids": []
}

# Response
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "details": {
      "field_errors": [
        {
          "field": "name",
          "code": "REQUIRED",
          "message": "Name is required for group chats"
        },
        {
          "field": "member_ids",
          "code": "MIN_LENGTH",
          "message": "At least one member is required"
        }
      ]
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

### C.2 Authorization Error

```http
DELETE /api/v1/chats/chat_01HQZ.../members/user_01HQX... HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...

# Response (user is 'member' role, cannot remove others)
HTTP/1.1 403 Forbidden
Content-Type: application/json

{
  "error": {
    "code": "FORBIDDEN",
    "message": "You do not have permission to remove members from this chat",
    "details": {
      "required_role": "admin",
      "your_role": "member"
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440001"
  }
}
```

### C.3 Not Found Error

```http
GET /api/v1/chats/chat_nonexistent HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...

# Response
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": {
    "code": "NOT_FOUND",
    "message": "Chat not found",
    "details": {
      "chat_id": "chat_nonexistent"
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440002"
  }
}
```

### C.4 Conflict Error

```http
POST /api/v1/chats/chat_01HQZ.../members HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json

{
  "user_id": "user_01HQX..."
}

# Response (user is already a member)
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": {
    "code": "ALREADY_A_MEMBER",
    "message": "User is already a member of this chat",
    "details": {
      "user_id": "user_01HQX...",
      "chat_id": "chat_01HQZ...",
      "joined_at": "2026-01-31T10:30:00.000Z"
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440003"
  }
}
```

---

## Appendix D: Invariants (Machine-Checkable)

```
INVARIANT authentication_required:
  ∀ endpoint E ∉ {/auth/*, /health}:
    request(E) without valid JWT → 401 Unauthorized

INVARIANT chat_membership_enforced:
  ∀ request R to /chats/{chat_id}/* (except POST /chats):
    user(R) ∉ members(chat_id) → 403 NOT_A_MEMBER

INVARIANT pagination_completeness:
  ∀ paginated_endpoint E, result_set S:
    following all next_cursor values retrieves all items in S

INVARIANT pagination_stability:
  ∀ cursor C generated at time T:
    using C at time T' > T returns items from the same logical position
    (new items may appear, but no items are skipped)

INVARIANT idempotency_guarantee:
  ∀ requests R1, R2 with same Idempotency-Key K within 24 hours:
    R1.user_id = R2.user_id →
    response(R1) = response(R2) ∧ state_change(R1) = state_change(R2)

INVARIANT rate_limit_headers_present:
  ∀ response R:
    R.headers contains X-RateLimit-Limit ∧
    R.headers contains X-RateLimit-Remaining ∧
    R.headers contains X-RateLimit-Reset

INVARIANT error_format_consistent:
  ∀ error response R:
    R.body contains error.code ∧
    R.body contains error.message ∧
    R.body contains error.request_id

INVARIANT sequence_consistency:
  ∀ message M returned by REST API, message M' delivered via WebSocket:
    M.message_id = M'.message_id →
    M.sequence = M'.sequence ∧
    M.content = M'.content ∧
    M.created_at = M'.created_at

INVARIANT delivery_state_monotonic:
  ∀ PATCH /delivery-state/{chat_id} with last_acked_sequence S:
    S ≤ current_delivery_state.last_acked_sequence → no update performed
    S > current_sequence → 422 UNPROCESSABLE_ENTITY

INVARIANT direct_chat_uniqueness:
  ∀ users A, B:
    |{chat C : C.type = direct ∧ members(C) = {A, B}}| ≤ 1

INVARIANT owner_cannot_leave:
  ∀ POST /chats/{id}/leave by user U:
    U.role = owner ∧ chat.type = group → 400 INVALID_OPERATION

INVARIANT member_count_accuracy:
  ∀ chat C:
    C.member_count = |members(C)|

INVARIANT ex_member_access_denied:
  ∀ user U, chat C, time T:
    removed_from_chat(U, C, T_remove) ∧ T > T_remove →
    GET /chats/{C}/messages by U → 403 NOT_A_MEMBER

INVARIANT device_binding_enforced:
  ∀ refresh request R with session S:
    R.headers.X-Device-ID ≠ S.device_id → 401 DEVICE_MISMATCH

INVARIANT direct_chat_idempotent_creation:
  ∀ POST /chats requests R1, R2 with type=direct, member_ids=[B]:
    R1.user = R2.user = A →
    response(R1).chat_id = response(R2).chat_id

INVARIANT message_page_no_duplicates:
  ∀ cursor C, pages P1 = fetch(C), P2 = fetch(P1.next_cursor):
    {m.message_id : m ∈ P1.data} ∩ {m.message_id : m ∈ P2.data} = ∅

INVARIANT retry_after_on_429:
  ∀ response R with status = 429:
    R.headers contains Retry-After ∧ R.headers.Retry-After > 0
```

---

## Appendix E: Client Implementation Checklist

### E.1 Required Behaviors

- [ ] Include `Authorization: Bearer {token}` header on all authenticated requests
- [ ] Include `X-Device-ID` header on `/auth/verify-otp` and `/auth/refresh`
- [ ] Store `device_id` securely and persistently (survives app restart)
- [ ] Handle 401 responses by refreshing token and retrying
- [ ] Handle 401 `DEVICE_MISMATCH` by re-authenticating with OTP
- [ ] Handle 429 responses by respecting `Retry-After` header
- [ ] Include `Idempotency-Key` header on POST/PATCH operations
- [ ] Implement cursor-based pagination for list endpoints
- [ ] Parse and display error messages from error response format
- [ ] Store and send `X-Request-ID` for debugging

### E.2 Recommended Behaviors

- [ ] Proactively refresh tokens before expiration
- [ ] Cache user profiles to reduce API calls
- [ ] Batch user lookups when displaying multiple senders
- [ ] Implement exponential backoff for 5xx errors
- [ ] Log all API errors with request_id for debugging
- [ ] Use `updated_since` parameter for efficient chat list refresh

### E.3 Anti-Patterns to Avoid

- [ ] DO NOT poll for new messages (use WebSocket)
- [ ] DO NOT change `device_id` between sessions (causes `DEVICE_MISMATCH`)
- [ ] DO NOT store access tokens in localStorage without encryption
- [ ] DO NOT retry on 4xx errors (except 401, 429)
- [ ] DO NOT assume response format for errors (always check `error.code`)
- [ ] DO NOT hardcode rate limits (read from response headers)
- [ ] DO NOT skip pagination (always check `has_more`)
- [ ] DO NOT assume idempotent replay returns identical response bodies
