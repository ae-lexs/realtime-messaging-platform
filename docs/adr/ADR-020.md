# ADR-020: Service Lifecycle Conventions — Setup Hooks, Resource Cleanup & gRPC Integration

- **Status**: Accepted
- **Date**: 2026-02-10

---

## Context and Problem Statement

ADR-018 extracted the shared service lifecycle runner (`server.Run`) with `Params{Name, PortFromConfig}`. PR-1 requires richer lifecycle support:
- Services need a hook to create infrastructure clients, adapters, and register gRPC/grpc-gateway handlers
- Resources created during setup (Redis client, background goroutines) must be cleaned up during shutdown
- Some services need a gRPC server alongside HTTP

ADR-018 documented the growth path: "When any service reaches 3+ concurrent components, migrate from Option A to Option B." PR-1 doesn't reach that threshold — it extends Option A with optional gRPC and a setup hook.

---

## Decision Drivers

1. **Dependencies must outlive dependents** (06_GRACEFUL_SHUTDOWN)
2. **Shutdown order reverses startup order** (06_GRACEFUL_SHUTDOWN)
3. **Every goroutine must have an owner responsible for its termination** (05_CONCURRENCY)
4. **Every startable component needs an explicit shutdown path** (06_GRACEFUL_SHUTDOWN)
5. **Context originates at system boundaries** (04_CONTEXT)

---

## Architecture Details

### Decision 5: Setup Callback with Cleanup Return

Extend `Params` with a `Setup` callback that returns an optional cleanup function:

```go
type Params struct {
    Name               string
    PortFromConfig     func(cfg *config.Config) int
    GRPCPortFromConfig func(cfg *config.Config) int          // nil = no gRPC
    Setup              func(ctx context.Context, deps SetupDeps) (cleanup func(context.Context) error, err error)
}

type SetupDeps struct {
    Config     *config.Config
    Logger     *slog.Logger
    HTTPMux    *http.ServeMux
    GRPCServer *grpc.Server  // nil if GRPCPortFromConfig is nil
}
```

Setup is the composition root: creates infrastructure clients, adapters, app services, registers handlers. The returned cleanup function is called during graceful shutdown.

Co-location rule: the function that creates a resource also defines its cleanup. This follows ADR-018's ownership hierarchy — "Each node owns the goroutines it spawns and is responsible for their cancellation and cleanup."

```go
// cmd/chatmgmt/setup.go — cleanup co-located with creation
cleanup := func(_ context.Context) error {
    authSvc.Wait()             // wait for background goroutines
    return redisClient.Close() // close infrastructure client
}
return cleanup, nil
```

Rules:
- Setup must return a cleanup function if it creates any closeable resource or starts background work
- Setup errors prevent server start — fail-fast, no partial initialization
- Cleanup receives a bounded context (`domain.ShutdownHTTPTimeout`) — must not block indefinitely
- Cleanup errors are logged but do not prevent remaining shutdown steps (OTEL flush continues)

Code reference: `internal/server/server.go:38–48` (Params), `cmd/chatmgmt/setup.go:43–131` (implementation)

### Decision 6: gRPC Server Lifecycle & Shutdown Ordering

gRPC is optional — controlled by `GRPCPortFromConfig`:
- `nil`: no gRPC server created, `SetupDeps.GRPCServer` is nil
- Non-nil: `grpc.NewServer()` created before Setup, passed via `SetupDeps` for service registration

Test injection via `Listeners` struct:

```go
type Listeners struct {
    HTTP net.Listener
    GRPC net.Listener
}
```

Shutdown ordering (extends ADR-018):

```
1. ctx.Done()               — signal received
2. shuttingDown.Store(true)  — health check returns 503
3. time.Sleep(drainDelay)    — wait for LB to stop routing
4. grpcServer.GracefulStop() — stop accepting new RPCs, finish in-flight
5. httpSrv.Shutdown(ctx)     — stop accepting new HTTP, finish in-flight
6. cleanupFn(ctx)            — close infra clients, wait on goroutines
7. mp.Shutdown(ctx)          — flush metrics
8. tp.Shutdown(ctx)          — flush traces
```

Why gRPC stops before HTTP: grpc-gateway routes through the HTTP mux. If HTTP stops first, in-flight grpc-gateway requests lose their transport. HTTP must outlive gRPC during drain. This follows the handbook rule: "Dependencies must outlive dependents."

Why cleanup runs after both servers stop: Cleanup may close connections (Redis, DynamoDB) that in-flight requests depend on. Servers must be fully drained before infrastructure clients are closed.

Code reference: `internal/server/server.go:241–287` (shutdownFunc)

---

## Consequences

### Positive

- **Single composition root per service** — all wiring visible in one function
- **Resource cleanup guaranteed** — co-located with creation, cannot be forgotten
- **gRPC is opt-in** — HTTP-only services (Gateway, Fanout) pass nil, no overhead
- **Test injection preserved** — port-0 listeners for both HTTP and gRPC

### Negative

- **Setup function can grow large** for services with many dependencies — mitigate by extracting helper functions (e.g., `createKeyStore`, `createSMSProvider`)
- **Single cleanup function** — if cleanup order between resources matters, the function must sequence them manually (acceptable at current scale; ADR-018's Component interface is the growth path)

---

## Confirmation

Every service's `cmd/*/setup.go` must satisfy:
- [ ] Setup returns `(cleanup, error)` — not just `error`
- [ ] Cleanup closes all infrastructure clients created in Setup
- [ ] Cleanup waits on all background goroutines started in Setup
- [ ] gRPC services set `GRPCPortFromConfig` and register services via `SetupDeps.GRPCServer`
- [ ] Tests use `server.Listeners{HTTP: ln}` (or `{HTTP: ln, GRPC: grpcLn}`) for port-0 injection

---

## References

- Go Senior-Level Handbook: [Graceful Shutdown](https://github.com/ae-lexs/go-senior-level-handbook/blob/main/06_GRACEFUL_SHUTDOWN.md)
- Go Senior-Level Handbook: [Concurrency Architecture](https://github.com/ae-lexs/go-senior-level-handbook/blob/main/05_CONCURRENCY_ARCHITECTURE.md)
- Go Senior-Level Handbook: [Context and Lifecycle](https://github.com/ae-lexs/go-senior-level-handbook/blob/main/04_CONTEXT_AND_LIFECYCLE.md)
- ADR-018: Service Lifecycle Extraction — `internal/server` Package
- ADR-014: Technology Stack & Service Architecture (graceful shutdown budget §4.1)
