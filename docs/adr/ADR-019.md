# ADR-019: Interface Contracts & Type Ownership Across Clean Architecture Layers

- **Status**: Accepted
- **Date**: 2026-02-10

---

## Context and Problem Statement

CONTRIBUTING.md defines layer hierarchy (`domain` ← `app` ← `port`/`adapter`) and dependency rules enforced by `go-arch-lint` + `depguard`. But it doesn't specify:
- Which layer owns shared types (records, params, results)
- How adapters bridge app types ↔ infrastructure serialization
- How consumer interfaces are structured at each boundary
- How multi-table transactions preserve app/adapter separation

PR-1 is the first vertical slice. Without codified conventions, future PRs diverge.

---

## Decision Drivers

1. **Interfaces belong to consumers, not producers** (DD_INTERFACE_PATTERNS)
2. **The bigger the interface, the weaker the abstraction** (DD_INTERFACE_PATTERNS)
3. **Accept interfaces, return structs** (DD_INTERFACE_PATTERNS)
4. **Define at point of use** (DD_INTERFACE_PATTERNS)
5. **A little copying is better than a little dependency** (Go Proverb — justifies conversion helpers over shared serialization types)

---

## Architecture Details

### Decision 1: App-Layer Type Ownership

The `app/` layer is the canonical owner of all entity types that cross layer boundaries: record types (`OTPRecord`, `UserRecord`, `SessionRecord`), parameter structs (`RegistrationParams`, `LoginParams`), and result types (`RequestOTPResult`, `VerifyOTPResult`, `RefreshResult`).

Rules:
- Adapters and ports import `app.*` types in their **public APIs**
- No layer may redefine a type with the same semantic meaning as an `app.*` type
- Domain types (`domain.ErrNotFound`, `domain.RealClock`, constants) remain in `internal/domain/`
- `domain/` owns types that are genuinely cross-service (shared by Gateway, Ingest, Fanout, ChatMgmt)
- `app/` owns types scoped to a single service's use cases

Anti-pattern: adapter defining its own `OTPRecord` with the same fields — creates nominal type mismatch, forces callers to copy field-by-field at call sites instead of at the adapter boundary.

Code reference: `internal/chatmgmt/app/auth_service.go:46–118`

### Decision 2: Consumer-Defined Narrow Interfaces at Every Boundary

Three levels of consumer-defined interfaces, each at a different architectural boundary:

**Level 1 — App → Adapter boundary**: The `app/` layer defines interfaces for each adapter it depends on. Each interface contains only the methods the app layer calls.

- Example: `app.OTPStore` (3 methods), `app.UserStore` (2 methods), `app.AuthTransactor` (2 methods), `app.RateLimiter` (3 methods)
- Code reference: `internal/chatmgmt/app/auth_service.go:120–159`

**Level 2 — Adapter → Infrastructure boundary**: Each adapter defines a private, narrow interface for the infrastructure client it wraps. Only the SDK methods this specific adapter calls are declared.

- Example: `otpDynamoDB` (3 methods: GetItem, PutItem, UpdateItem), `txDynamoDB` (1 method: TransactWriteItems), `smClient` (1 method: GetSecretValue)
- Code reference: `internal/chatmgmt/adapter/dynamo_otp.go:24–28`, `dynamo_tx.go:20–22`

**Level 3 — Port → App boundary**: The port layer defines a private interface for the app-layer service it calls. The concrete `*app.AuthService` satisfies this interface implicitly.

- Example: `authService` interface (4 methods: RequestOTP, VerifyOTP, RefreshTokens, Logout)
- Code reference: `internal/chatmgmt/port/auth_handler.go:19–24`

Compile-time verification: Every adapter file includes a static assertion.

- Pattern: `var _ app.OTPStore = (*OTPStore)(nil)`
- Code reference: `internal/chatmgmt/adapter/dynamo_otp.go:18`

Testing benefit: A 1-method infrastructure interface needs a 1-method stub. A 4-method service interface in the port needs a 4-method stub with function fields. No mock library required.

### Decision 3: Adapter Boundary Types with Field-by-Field Conversion

Adapters define private "item" structs with infrastructure-specific tags (`dynamodbav`) for serialization. These are never exposed in public APIs.

Pattern:
- Private type: `otpItem struct { PhoneHash string \`dynamodbav:"phone_hash"\` ... }`
- Conversion in: `toOTPItem(app.OTPRecord) otpItem`
- Conversion out: `fromOTPItem(otpItem) *app.OTPRecord`
- Explicit field-by-field mapping (Go's nominal type system prevents direct struct conversion when field order differs; this is desirable as documentation of the mapping)

Code reference: `internal/chatmgmt/adapter/dynamo_otp.go:30–69`

Rationale: "A little copying is better than a little dependency." The conversion boilerplate is small, localized, and eliminates the alternative — leaking `dynamodbav` tags into app-layer types or creating a shared serialization package that couples all layers to DynamoDB conventions.

### Decision 4: Transactor Encapsulation

Multi-table atomic operations accept app-layer parameter structs and build infrastructure operations internally.

Pattern:
- App layer defines parameter types: `RegistrationParams`, `LoginParams`
- App layer defines transactor interface: `AuthTransactor` with business-named methods (`VerifyOTPAndCreateUser`, `VerifyOTPAndCreateSession`)
- Adapter's `Transactor` accepts these params and uses private builder methods (`buildOTPVerifyUpdate`, `buildUserPut`, `buildPhoneSentinelPut`, `buildSessionPut`) to construct DynamoDB `TransactWriteItem` objects
- Error classification (`classifyTxError`) maps DynamoDB cancellation reasons to domain errors — this logic is adapter-owned because it knows which item in the transaction corresponds to which business constraint

Code reference: `internal/chatmgmt/adapter/dynamo_tx.go:55–84` (method), `app/auth_service.go:88–118` (params)

Rationale: Business semantics (what data participates in a registration) stay in app. Infrastructure details (how to build a conditional PutItem with expression attribute names) stay in adapter. Both sides are independently testable.

---

## Consequences

### Positive

- **Single type authority** — changing a record field requires changing one package
- **Simple test doubles** — consumer-defined interfaces need minimal stubs
- **Infrastructure isolation** — switching from DynamoDB to PostgreSQL changes only adapter + conversion helpers
- **Nominal type safety** — Go compiler catches mismatches between layers at compile time

### Negative

- **Conversion boilerplate** — every adapter field must be mapped explicitly in helpers
- **Adapter depends on app** — app-layer type changes can break adapter compilation (accepted: adapter is a leaf, not imported by others)

---

## Confirmation

Every PR must satisfy:
- [ ] No duplicate type definitions across layers — `app/` owns all cross-boundary types
- [ ] Every adapter has `var _ app.Interface = (*Type)(nil)` compile-time check
- [ ] Adapter public APIs accept/return `app.*` types only — private item types for serialization
- [ ] Infrastructure interfaces are consumer-defined, private, and minimal
- [ ] Transactors accept app-layer param types and build operations internally
- [ ] Port-layer service interfaces are private and contain only methods the handler calls

---

## References

- Go Senior-Level Handbook: [Interface Patterns](https://github.com/ae-lexs/go-senior-level-handbook/blob/main/DD_INTERFACE_PATTERNS.md)
- Go Senior-Level Handbook: [Context and Lifecycle](https://github.com/ae-lexs/go-senior-level-handbook/blob/main/04_CONTEXT_AND_LIFECYCLE.md)
- CONTRIBUTING.md §Clean Architecture, §Interface Placement, §Domain Modeling
- docs/standards/GO.md §Interface Invariants
- ADR-018: Service Lifecycle Extraction
